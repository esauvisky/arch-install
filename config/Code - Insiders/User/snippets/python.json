{
    // Place your snippets for python here. Each snippet is defined under a snippet name and has a prefix, body and
    // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the
    // same ids are connected.
    // Example:
    "Boilerplate (argparse with custom formatter)": {
        "description": "Default starting boilerplate for Python scripts with argument parsing.",
        "prefix": "pythonargparse",
        "body": [
            "import argparse",
            "",
            "if __name__ == \"__main__\":",
            "",
            "    class Formatter(argparse.RawTextHelpFormatter, argparse.ArgumentDefaultsHelpFormatter):",
            "        pass",
            "    ",
            "    PARSER = argparse.ArgumentParser(prog=\"smeargle\", formatter_class=Formatter)",
            "    PARSER.add_argument(\"-p\", \"--package\", default=\"com.nianticlabs.pokemongo\")",
            "    PARSERS = PARSER.add_subparsers(title=\"subcommands\", dest=\"action\")",
            "    DOWNLOAD_PARSER = PARSERS.add_parser(\"download\", add_help=False, formatter_class=Formatter)",
            "    DOWNLOAD_PARSER.add_argument(\"-s\", \"--scan\", action=\"store_true\")",
            "    REFRESH_PARSER = PARSERS.add_parser(\"refresh\", add_help=False, formatter_class=Formatter) #yapf: disable",
            "",
            "    for subparsers_action in [action for action in PARSER._actions if isinstance(action, argparse._SubParsersAction)]:",
            "        for choice, subparser in subparsers_action.choices.items():",
            "            help_lines = subparser.format_help().split(\"\\n\")",
            "            help_lines[0] = \"\\n\\u001b[34;01m\" + help_lines[0].replace(\"usage: \", \"\")",
            "            help_lines.pop(1)",
            "            help_lines[1] = \"\\u001b[34m\" + help_lines[1] + \"\\u001b[00m\"",
            "            PARSER.epilog = (PARSER.epilog or \"\") + (\"\\u001b[00m\\n\\u001b[36;00m\".join(help_lines[0:2]) + \"\\n\" +",
            "                                                     (\"\\n  \").join(help_lines[2:]))",
            "",
            "    args = PARSER.parse_args()",
        ]
    },
    "Boilerplate (async with argparse)": {
        "description": "Default starting boilerplate for Python scripts with argument parsing.",
        "prefix": "pythonbpasync",
        "body": [
            "#!/usr/bin/env python3",
            "import argparse",
            "import asyncio",
            "from sys import platform",
            "",
            "",
            "class Main:",
            "    def __init__(self, args):",
            "        self.args = args",
            "",
            "    async def start(self):",
            "        logger.info(\"hello world\")",
            "        logger.info(self.args)",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    if platform == 'win32':",
            "        asyncio.set_event_loop_policy(asyncio.WindowsProactorEventLoopPolicy())",
            "    parser = argparse.ArgumentParser()",
            "",
            "    # Required single positional argument",
            "    parser.add_argument(\"arg\",",
            "                        help=\"Required positional argument (a single thing).\")",
            "",
            "    # Required multime positional arguments",
            "    parser.add_argument('items', nargs='+',",
            "                        help='Required various positional arguments (a list).')",
            "",
            "    # Optional argument flag which defaults to False",
            "    parser.add_argument(\"-f\", \"--flag\", action=\"store_true\", default=False,",
            "                        help=\"Activate Flag (false by default)\")",
            "",
            "    # Optional argument which requires a parameter (eg. -d test)",
            "    parser.add_argument(\"-n\", \"--name\", action=\"store\", dest=\"name\",",
            "                        help=\"Specifies a name if necessary.\")",
            "",
            "    # Optional extra verbosity level.",
            "    parser.add_argument(\"-v\", \"--verbose\", action=\"store_const\", default=\"INFO\", const=\"DEBUG\",",
            "                        help=\"Increases verbosity. Shows debugging log messages.\")",
            "",
            "    # Specify output of \"--version\"",
            "    parser.add_argument(\"--version\", action=\"version\", ",
            "                        version=\"%(prog)s (version {version})\".format(version=__version__))",
            "",
            "    args = parser.parse_args()",
            "    logger.setLevel(args.verbose)",
            "",
            "    asyncio.run(Main(args).start())",
        ]
    },
    "Timing Decorator": {
        "description": "Timing decorator for functions.",
        "prefix": "pythontiming",
        "body": [
            "import time",
            "",
            "def timeit(func):",
            "    \"\"\" Decorator to time and report elapsed time of functions \"\"\"",
            "    def wrapped(*args, **kwargs):",
            "        start = time.time()",
            "        result = func(*args, **kwargs)",
            "        end = time.time()",
            "        logger.debug(f'Function {func.__name__} executed in {end - start:f} s')",
            "        return result",
            "    return wrapped"
        ]
    },
    "Logging Boilerplate": {
        "description": "Basic logging boilerplate with custom formatter.",
        "prefix": "pythonbplogging",
        "body": [
            "from loguru import logger",
            "",
            "def setup_logging(log_lvl=\"DEBUG\", options={}):",
            "    file = options.get(\"file\", False)",
            "    function = options.get(\"function\", False)",
            "    process = options.get(\"process\", False)",
            "    thread = options.get(\"thread\", False)",
            "",
            "    log_fmt = (u\"<n><d><level>{time:HH:mm:ss.SSS} | \" +",
            "               f\"{'{file:>15.15}' if file else ''}\" +",
            "               f\"{'{function:>15.15}' if function else ''}\" +",
            "               f\"{':{line:<4} | ' if file or function else ''}\" +",
            "               f\"{'{process.name:>12.12} | ' if process else ''}\" +",
            "               f\"{'{thread.name:<11.11} | ' if thread else ''}\" +",
            "               u\"{level:1.1} | </level></d></n><level>{message}</level>\")",
            "",
            "    logger.configure(",
            "        handlers=[{",
            "            \"sink\": lambda x: print(x, end=\"\"),",
            "            \"level\": log_lvl,",
            "            \"format\": log_fmt,",
            "            \"colorize\": True,",
            "            \"backtrace\": True,",
            "            \"diagnose\": True",
            "        }],",
            "        levels=[",
            "            {\"name\": \"TRACE\", \"color\": \"<white><dim>\"},",
            "            {\"name\": \"DEBUG\", \"color\": \"<cyan><dim>\"},",
            "            {\"name\": \"INFO\", \"color\": \"<white>\"}",
            "        ]",
            "    )  # type: ignore # yapf: disable",
            "",
            "setup_logging(\"DEBUG\", {\"function\": True, \"thread\": True})",
        ]
    },
    "argparse with ordered arguments": {
        "description": "Overloads argparse to allow looping through arguments in the order they were passed.",
        "prefix": "argparseordered",
        "body": [
            "class OrderedNamespace(argparse.Namespace):",
            "    \"\"\"",
            "    Allows to parse arguments in the order they were passed",
            "    \"\"\"",
            "    def __init__(self, **kwargs):",
            "        self.__dict__[\"_order\"] = [None]",
            "        super().__init__(**kwargs)",
            "    def __setattr__(self, attr, value):",
            "        super().__setattr__(attr, value)",
            "        if attr in self._order:",
            "            self.__dict__[\"_order\"].clear()",
            "        self.__dict__[\"_order\"].append(attr)",
            "    def ordered(self):",
            "        if self._order and self._order[0] is None:",
            "            self._order.clear()",
            "        return ((attr, getattr(self, attr)) for attr in self._order)",
            "",
            "parser.add_argument(\"-s\", \"--script\", dest=\"encrypt_script\", action=\"store\", default=None,",
            "                    help=\"Encrypts a script and saves it for each abi at custom/lib/*/libpokemod.script.so\")",
            "",
            "parser.add_argument(\"-i\", \"--inject-gadget\", dest=\"native_library\", action=\"store\", default=\"extracted/lib/arm64-v8a/libNianticLabsPlugin.so\",",
            "                    help=\"Injects a call to load libpokemod.so into a native library.\")",
            "",
            "args = parser.parse_args(namespace = OrderedNamespace())",
            "",
            "for arg in args._order:",
            "    if arg == \"encrypt_script\":",
            "        value = Path(getattr(args, arg))",
        ],
    },
    "Yes/No prompt": {
        "description": "Simple Yes/No terminal prompt",
        "prefix": "ynprompt",
        "body": [
            "if not input().lower() == \"y\":",
            "    sys.exit(1)"
        ],
    },
    "Run external command": {
        "description": "subprocess run external command with stdout/stderr piping and shlex splitting",
        "prefix": "subrun",
        "body": [
            "subprocess.run(shlex.split(\"${0}\"))",
        ],
    },
    "Split loop into several threads or processes": {
        "prefix": "pythonsplitloop",
        "body": [
            "import concurrent",
            "",
            "def process(items):",
            "    for item in in items:",
            "        # your code here",
            "        ",
            "def grouper(iterable, n, *, incomplete='ignore', fillvalue=None):",
            "    args = [iter(iterable)] * n",
            "    if incomplete == 'fill':",
            "        return zip_longest(*args, fillvalue=fillvalue)",
            "    if incomplete == 'strict':",
            "        return zip(*args, strict=True)",
            "    if incomplete == 'ignore':",
            "        return zip(*args)",
            "    else:",
            "        raise ValueError('Expected fill, strict, or ignore')",
            "",
            "def split_tasks(items, threads=4, use_threads=False):",
            "    split_size = len(items) // threads",
            "    if use_threads:",
            "        executor = concurrent.futures.ThreadPoolExecutor(max_workers=threads)",
            "    else:",
            "        executor = concurrent.futures.ProcessPoolExecutor(max_workers=threads)",
            "        ",
            "    futures = [executor.submit(process, group) for group in grouper(items, split_size)]",
            "    concurrent.futures.wait(futures)",
            "    ",
            "    return itertools.chain.from_iterable(futures)",
            "",
            "results = split_tasks(iterable, 8)",
        ]
    },
    "IPDB debugging": {
        "description": "Debug Python code using IPDB",
        "prefix": [
            "ipdb",
            "debugger"
        ],
        "body": [
            "import ipdb; ipdb.set_trace()",
        ],
    },
}
