[Commands]
1\Command="
    const _print = global.print;
    global.print = function (arg) {
        popup(arg);
        _print(arg + \"\\n\");
    }

    const clipboardTab = '&Clipboard';
    const selectionTab = '&Primary Selection';
    const imageTab = '&Images';
    const timeFormat = 'MM-dd hh:mm:ss'
    const tagsMime = 'application/x-copyq-tags';

    const mimeImage = 'image/png';
    const mimeHtml = 'text/html';
    const mimeText = 'text/plain';
    const mimeClipboardMode = 'application/x-copyq-clipboard-mode';
    const mimeOutputTab = 'application/x-copyq-output-tab';

    global.paste = function () {
        paste_();
    }
    var paste_ = global.paste;

    // --- NEW HELPER FUNCTION ---
    // Checks the top 100 items of the current tab. 
    // If a duplicate is found, it removes it (so the new add() puts it at the top).
    global.removeIfExists = function(mime, contentData) {
        if (!contentData) return;

        // Use SHA1 for reliable comparison of both Text and Image binary data
        const targetHash = sha1sum(contentData);
        
        // Performance optimization: Only check the most recent 100 items
        const limit = 100; 
        const total = count();
        const max = total > limit ? limit : total;

        for (var i = 0; i < max; i++) {
            // Read data from history item
            const itemData = read(mime, i);
            
            // If hashes match, delete the old one
            if (targetHash === sha1sum(itemData)) {
                remove(i);
                return; // Stop after removing the first match
            }
        }
    }

    const _onClipboardChanged = onClipboardChanged;
    onClipboardChanged = function () {
        if (!hasData()) {
            print(\"doesnt have data!\");
            updateClipboardData();
        } else if (runAutomaticCommands()) {
            var time = Date.now();
            var tags = dateString(timeFormat);

            // --- 2. Determine the correct tab and apply specific logic ---
            if (data(mimeClipboardMode) != \"selection\" && isClipboard()) {
                
                if (hasClipboardFormat(mimeImage)) {
                    // IMAGE LOGIC
                    var imageClipboard = clipboard(mimeImage);
                    setCurrentTab(imageTab);
                    tab(imageTab);
                    
                    // >>>> DEDUPLICATION CALL <<<<
                    removeIfExists(mimeImage, imageClipboard);

                    item = {}
                    item[mimeOutputTab] = imageTab;
                    item[mimeImage] = imageClipboard;
                    add(item);
                    setData('application/x-copyq-user-copy-time', time);
                    abort();

                } else {
                    // TEXT CLIPBOARD LOGIC
                    // Note: We must check duplication before saveData() logic
                    setCurrentTab(clipboardTab);
                    
                    // >>>> DEDUPLICATION CALL <<<<
                    // We check against the text content
                    removeIfExists(mimeText, data(mimeText));

                    saveData();
                    setData(mimeOutputTab, clipboardTab);

                    const clipboardText = str(data(mimeText));
                    const numLines = clipboardText ? (clipboardText.match(/\\n/g) || []).length + 1 : 0;
                    if (numLines > 1) tags = 'Lines: ' + numLines + ',' + tags;

                    const languageDetected = detectLanguage(clipboardText);
                    if (languageDetected) {
                        tags = languageDetected + ',' + tags;
                        var htmlCode = highlightCode(clipboardText, languageDetected);
                        if (htmlCode) setData(mimeHtml, htmlCode);
                    }
                    setData(tagsMime, tags);
                    setData('application/x-copyq-user-copy-time', time);
                }
            } else {
                // SELECTION LOGIC
                //print(\"got selection clipboard: \" + data(mimeOutputTab));
                tab(selectionTab);

                // >>>> DEDUPLICATION CALL <<<<
                removeIfExists(mimeText, data(mimeText));

                const item = {}
                item[mimeOutputTab] = selectionTab;
                
                const clipboardText = str(data(mimeText));
                item[mimeText] = clipboardText;
                
                const numLines = clipboardText ? (clipboardText.match(/\\n/g) || []).length + 1 : 0;
                if (numLines > 1) tags = \"Lines: \" + numLines + ',' + tags;

                const languageDetected = detectLanguage(clipboardText);
                if (languageDetected) {
                    tags = languageDetected + ',' + tags;
                    var htmlCode = highlightCode(clipboardText, languageDetected);
                    if (htmlCode) item[mimeHtml] = htmlCode;
                }
                item[tagsMime] = tags;
                add(item);
                setData('application/x-copyq-user-copy-time', time);
                abort();
            }
        } else {
            print(\"clearing clipboard data!\");
            clearClipboardData();
        }
    }


    global.hasImageFormat = function (formats) {
        for (const format of formats.values()) {
            if (format.startsWith('image/'))
                return true;
        }
        return false;
    }

    global.detectLanguage = function (text) {
        // Check for null/undefined/empty text
        if (!text || text.trim().length === 0) {
            return \"\";
        }

        const highConfidencePatterns = {
            \"python\": /\\bdef\\s+\\w+\\s*\\(.*\\):|\\bfrom\\s+[^\\s]+\\s+import\\s|import\\s+\\w+(\\s+as\\s+\\w+)?\\s*$|\\bclass\\s+\\w+(\\(.*\\))?:/gm,
            \"javascript\": /\\b(const|let|var)\\s+\\w+\\s*=\\s*.*;|\\bfunction\\s+\\w*\\s*\\(.*\\)\\s*\\{|\\b=>\\s*\\{|\\bimport\\s+.+\\s+from\\s+['\"].+['\"];?/gm,
            \"html\": /^\\s*<!DOCTYPE\\s+html>|<html[\\s>]/i,
            \"csharp\": /^\\s*namespace\\s+\\w+(\\.\\w+)*\\s*\\{|\\bpublic\\s+(class|interface|struct|enum)\\s+\\w+\\s*(?::\\s*\\w+)?\\s*\\{|\\busing\\s+System(\\.\\w+)*\\s*;/gm,
            \"cpp\": /^\\s*#include\\s*<[^>]+>|\\bint\\s+main\\s*\\(.*\\)\\s*\\{|\\bstd::\\w+/gm,
            \"java\": /^\\s*public\\s+(class|interface|enum)\\s+\\w+(\\s+extends\\s+\\w+)?(\\s+implements\\s+[\\w,\\s]+)?\\s*\\{|\\bimport\\s+java\\.\\w+/gm,
            \"go\": /^\\s*package\\s+\\w+|\\bfunc\\s+\\w+\\s*\\(.*\\)\\s*\\{|\\btype\\s+\\w+\\s+struct\\s*\\{/gm,
            \"php\": /^<\\?php|\\bfunction\\s+\\w+\\s*\\(.*\\)\\s*\\{|\\bclass\\s+\\w+\\s*(?:extends\\s+\\w+)?\\s*\\{/gm,
        };

        const lowConfidencePatterns = {
            \"python\": /\\bprint\\s*\\(.*\\)\\s*$|\\bif\\s+.*:\\s*$|\\bfor\\s+.*:\\s*$|\\bwhile\\s+.*:\\s*$|\\btry:\\s*$|\\bexcept\\s+.*:\\s*$|\\bwith\\s+.*:\\s*$/gm,
            \"javascript\": /console\\.(log|warn|error)\\(.*\\);?$|document\\.\\w+\\(.*\\);?$|window\\.\\w+\\(.*\\);?$/gm,
            \"html\": /<\\/?(div|span|p|a|img|ul|li|table|tr|td|script|style|head|body|meta|link)[\\s>]/i,
            \"csharp\": /Console\\.\\w+\\(.*\\);?$|using\\s+System(\\.\\w+)*\\s*;/gm,
            \"cpp\": /\\bcout\\s*<<.*;?$|\\bcin\\s*>>.*;?$|#define\\s+\\w+/gm,
            \"java\": /System\\.out\\.print(ln)?\\(.*\\);?$|\\bScanner\\s+\\w+\\s*=\\s*new\\s+Scanner\\(.*\\);?$|\\bpublic\\s+static\\s+void\\s+main\\s*\\(.*\\)\\s*\\{/gm,
            \"go\": /fmt\\.\\w+\\(.*\\);?$|\\bmake\\(\\w+\\)|\\bappend\\(\\w+,\\s*\\w+\\)/gm,
            \"kotlin\": /\\bprintln\\(.+\\);?$|\\bwhen\\s*\\(.*\\)\\s*\\{/gm,
        };

        try {
            JSON.parse(text);
            return \"json\";
        } catch (e) {
        }

        const highConfidenceWeight = 10;
        const lowConfidenceWeight = 1;

        let scores = {};

        for (const lang in highConfidencePatterns) {
            const pattern = highConfidencePatterns[lang];
            const matches = (text.match(pattern) || []).length;
            if (matches > 0) {
                scores[lang] = (scores[lang] || 0) + matches * highConfidenceWeight;
            }
        }

        for (const lang in lowConfidencePatterns) {
            const pattern = lowConfidencePatterns[lang];
            const matches = (text.match(pattern) || []).length;
            if (matches > 0) {
                scores[lang] = (scores[lang] || 0) + matches * lowConfidenceWeight;
            }
        }

        const sortedLanguages = Object.keys(scores).sort((a, b) => scores[b] - scores[a]);
        if (sortedLanguages.length === 0) return \"\";

        const topLanguage = sortedLanguages[0];
        const topScore = scores[topLanguage];
        const secondScore = scores[sortedLanguages[1]] || 0;

        if (topScore > 5 && topScore > secondScore * 1.5) {
            return topLanguage;
        }
        return \"\";
    }

    global.highlightCode = function (text, language) {
        const languageMap = {
            \"python\": \"python\",
            \"javascript\": \"javascript\",
            \"html\": \"html\",
            \"php\": \"php\",
            \"csharp\": \"csharp\",
            \"cpp\": \"cpp\",
            \"java\": \"java\",
            \"go\": \"go\",
            \"kotlin\": \"kotlin\",
            \"json\": \"json\",
            \"css\": \"css\",
        };

        const pygmentsLanguage = languageMap[language];
        if (!pygmentsLanguage) {
            return;
        }

        const pythonCode = `
    import sys
    from pygments import highlight
    from pygments.lexers import get_lexer_by_name
    from pygments.formatters import HtmlFormatter

    code = sys.stdin.read()
    lexer = get_lexer_by_name(sys.argv[1])
    formatter = HtmlFormatter(noclasses=True, style='solarized-dark', encoding='utf-8')
    formatter.style.background_color = 'none'
    print(highlight(code, lexer, formatter).decode())
    `;

        const result = execute('python3', '-c', pythonCode, pygmentsLanguage, null, text);

        if (result && result.exit_code === 0) {
            const html = result.stdout;
            return html
        } else {
            print('Error highlighting code: ' + (result ? result.stderr : 'Unknown error'));
        }
    }"
1\Icon=
1\IsScript=true
1\Name=Globals and Processors
2\Command="
    copyq:
    global.copyImageToClipboard = function(path) {
        const imageTab = '&Images';
        var f = new File(path)
        if (!f.openReadOnly())
            throw 'Failed to open the file: ' + f.errorString()
        var bytes = f.readAll()
        
        tab(imageTab)
        setCurrentTab(imageTab)
        // Write the image data to the clipboard with the MIME type 'image/png'
        write(0, 'image/png', bytes);
        copy('image/png', bytes);
    }"
2\Input=image/png
2\IsScript=true
2\Name=Copy PNG File Contents
2\Tab=&Images
3\Command="
    /**
     * Uploads content to either a Markdown or code sharing service based on the specified type.
     * - Checks existing tags to avoid duplicate uploads.
     * - Trims all tags to remove leading or trailing whitespace.
     * - Handles uploading to different endpoints based on the content type.
     * @param {string} type - The type of the content to upload, either 'code' or 'markdown'.
     */
    global.upload = function(type = \"code\") {
        const row = currentItem();
        const currentTags = getTags(row);

        // Check if a markdown or hastebin link already exists in the tags
        const existingLink = findExistingLink(currentTags);
        if (existingLink) return;  // Exit if a link already exists

        const itemText = getItemText(row);
        let responseParsed;
        if (type == 'markdown') {
            var finalMarkdown = escapeSpecialChars(itemText);
            responseParsed = postMarkdown(finalMarkdown);
        } else if (type == 'code') {
            responseParsed = postCode(itemText);
        }

        // Handle response and process the link
        if (handleResponseErrors(responseParsed)) {
            const link = processLink(responseParsed, type);
            updateTagAndCopyLink(row, link, type);
        }
    };

    function getTags(row) {
        return str(read(\"application/x-copyq-tags\", row)).split(\",\")
               .map(tag => tag.trim());  // Trim each tag to remove any leading or trailing whitespace
    }

    function findExistingLink(tags) {
        return tags.find(tag => tag.startsWith(\"Markdown: \") || tag.startsWith(\"Hastebin: \"));
    }

    function getItemText(row) {
        return str(read(row));
    }

    function escapeSpecialChars(str) {   
        return str.replace(/```/g, \"\\`\\`\\`\");
    }

    function postMarkdown(bodyText) {
        const endpoint = \"https://paper.wf/api/posts\";
        const postData = JSON.stringify({ \"body\": bodyText });
        const headers = [
            \"-H\", \"Content-Type: application/json\",
            \"-H\", \"Authorization: Token 1afc5558-f587-4012-4e93-1d33a16df8d5\"
        ];
        const response = execute(\"curl\", \"-s\", \"-X\", \"POST\", endpoint, ...headers, \"-d\", postData);
        return JSON.parse(str(response.stdout));
    }

    function postCode(bodyText) {
        const endpoint = \"https://haste.zneix.eu/documents\";
        const headers = [\"-H\", \"User-Agent: haste-client/1.2\"];
        const response = execute(\"curl\", \"-s\", \"-X\", \"POST\", endpoint, ...headers, \"--data\", bodyText);
        const jsonResponse = JSON.parse(str(response.stdout));
        return { data: { url: `https://haste.zneix.eu/${jsonResponse.key}` } };
    }

    function handleResponseErrors(response) {
        if (response.exit_code || response.stderr || response.error) {
            const errorMessage = `Failed to upload post: ${response.stderr} ${response.error}`;
            popup(errorMessage);
            abort();
            return false;
        }
        return true;
    }

    function processLink(response, type = \"code\") {
        if (type == \"markdown\") {
            url = response.data.url.slice(0, -3);
        } else {
            url = response.data.url;
        }
        return url;
    }

    function updateTagAndCopyLink(row, link, type) {
        const prefix = type === 'code' ? 'Hastebin: ' : 'Markdown: ';
        const tagData = `${prefix}${link}`;
        
        const currentData = str(read(\"application/x-copyq-tags\", row));
        setData(\"application/x-copyq-tags\", `${tagData},${currentData}`, row);
        copy(link);
    }
    "
3\Icon=
3\IsScript=true
3\Name=Upload to Write.as or Hastebin
4\Command="

    global.joinLines = function () {
        // Step 1: Get clipboard content and perform basic validation
        const contents = str(clipboard());
        if (!contents || !contents.trim()) {
            abort(\"Clipboard is empty or contains only whitespace.\");
        }

        // Step 2: Prompt the user for the separator string
        const separator = dialog(
            'Enter separator (e.g., \", \" or \" | \")', // Prompt Label
            '\", \"'                                // Default Separator
        );

        // Step 3: Handle cancellation
        // If the user clicks \"Cancel\" or closes the dialog, dialog() returns `undefined`.
        // We simply stop the script's execution.
        if (separator === undefined) {
            return; // Silently abort the operation
        }

        // Step 4: Process the input text
        // - Split the content into an array of lines
        // - For each line, trim leading/trailing whitespace
        // - Filter out any lines that are now empty
        const processedLines = contents.split('\\n')
            .map(line => line.trim())
            .filter(line => line.length > 0);

        // Abort if, after cleaning, there's nothing to join.
        if (processedLines.length === 0) {
            abort(\"No non-empty lines found to join.\");
        }

        // Step 5: Join the cleaned lines and apply conditional wrapping
        const joinedString = processedLines.join(separator);
        let finalString = joinedString; // Default to the unwrapped string

        // --- Conditional Wrapping Logic ---
        if (separator.length > 0) {
            const firstChar = separator.charAt(0);
            const lastChar = separator.charAt(separator.length - 1);

            // Check if the separator starts and ends with the same, non-whitespace character
            if (firstChar === lastChar && firstChar.trim() !== '') {
                const wrapper = firstChar;
                finalString = wrapper + joinedString + wrapper;
            }
        }

        // Step 6: Update the clipboard with the final result
        copy(finalString);
        copySelection(finalString);
        add(finalString);
    };"
4\Icon=
4\IsScript=true
4\Name=Join Lines
5\Command="
    copyq:
    var color = 'rgba(255, 255, 0, 1)'
    var currentColor = str(selectedItemData(0)[mimeColor]);
    if (currentColor != color) {
        setData(mimeColor, color)
    } else {
        removeData(mimeColor)
    }"
5\Icon=
5\InMenu=true
5\MatchCommand="
    copyq:
    var color = 'rgba(255, 255, 0, 0.5)'
    var currentColor = str(selectedItemData(0)[mimeColor])
    if (currentColor != color) {
        menuItem['text'] = 'Mark Items'
        menuItem['tag'] = '__'
        menuItem['color'] = color.replace(/\\d+\\.\\d+/, 1)
    } else {
        menuItem['text'] = 'Unmark Items'
        menuItem['tag'] = 'x'
        menuItem['color'] = 'white'
    }
    menuItem['icon'] = ''"
5\Name=Highlight Items
6\Command="
    global.codeblock = function (mode = 'copy') {
        // Step 1: Check the clipboard content
        var contents = str(clipboard());
        if (!contents || !contents.trim() || (contents.trim().startsWith(\"```\") && contents.trim().endsWith(\"```\"))) {
            abort(\"Clipboard is empty, contains only whitespace, or already looks like a code block.\");
        }

        // Step 2: Define helper functions
        function escapeSpecialChars(str) {
            return str.replace(/```/g, \"\\\\`\\\\`\\\\`\");
        }

        function removeExtraIndentation(text) {
            const lines = text.split('\\n');

            // Find the index and content of the first line with actual content
            let firstContentLineIndex = -1;
            let firstContentLine = null;
            for (let i = 0; i < lines.length; i++) {
                if (/\\S/.test(lines[i])) { // Check if the line has non-whitespace characters
                    firstContentLineIndex = i;
                    firstContentLine = lines[i];
                    break;
                }
            }

            // If no content lines found, or only one line, return original text
            if (firstContentLineIndex === -1 || lines.filter(line => /\\S/.test(line)).length <= 1) {
                return text;
            }

            const firstLineIndent = firstContentLine.match(/^\\s*/)[0].length;

            // --- Special Case Trigger: First non-empty line starts at column 0 ---
            if (firstLineIndent === 0) {
                // Find all *other* non-empty lines (those after the first content line)
                // Need to consider all lines, not just those after, in case structure is like:
                // line0
                //   line1
                // line0_again
                const otherContentLines = lines.filter((line, index) =>
                    index !== firstContentLineIndex && /\\S/.test(line)
                );


                // If there are no other content lines, no relative indentation to adjust
                if (otherContentLines.length === 0) {
                    return text;
                }

                // Calculate the minimum indentation among these *other* content lines
                const secondaryMinIndent = Math.min(...otherContentLines.map(line => line.match(/^\\s*/)[0].length));

                // If this secondary minimum is greater than 0, apply the special dedent
                if (secondaryMinIndent > 0) {
                    return lines.map(line => {
                        // Only modify lines that ARE indented
                        if (/^\\s+/.test(line)) { // Check if line starts with whitespace
                           const currentIndent = line.match(/^\\s*/)[0].length;
                           // Remove secondaryMinIndent if the line has at least that much indent
                           if (currentIndent >= secondaryMinIndent) {
                               return line.substring(secondaryMinIndent);
                           }
                        }
                        // Otherwise (line starts at 0 or has less indent than secondaryMinIndent), return unchanged
                        return line;
                    }).join('\\n');
                } else {
                    // If secondaryMinIndent is 0, it means all relevant subsequent lines also start near 0.
                    // No indentation adjustment needed relative to the first line.
                    return text;
                }
            } else {
                // --- Standard Dedent Case: First non-empty line IS indented ---
                // Find all content lines (including the first one)
                const allContentLines = lines.filter(line => /\\S/.test(line)); // Reuse filter logic

                // Calculate the minimum indentation across ALL content lines
                const absoluteMinIndent = Math.min(...allContentLines.map(line => line.match(/^\\s*/)[0].length));

                // If minimum is 0 (shouldn't normally happen here, but safe check), return text
                if (absoluteMinIndent === 0 ) {
                     return text;
                }

                // Remove the absolute minimum indentation from ALL lines
                return lines.map(line => line.substring(absoluteMinIndent)).join('\\n');
            }
        }


        // Step 3: Process the content
        contents = removeExtraIndentation(contents);
        contents = escapeSpecialChars(contents);

        // Step 4: Detect language and format
        const language = detectLanguage(contents) || '';
        const formattedText = `\\`\\`\\`${language}\\n${contents}\\n\\`\\`\\``;

        // Step 5: Output the result (Using the improved replace/copy logic from previous versions)
        if (mode == \"replace\") {
           const currentIdx = index();
           if (currentIdx >= 0) {
               try {
                   replace(currentIdx, formattedText);
                   // Ensure clipboard consistency after replacing
                   copy(formattedText);
                   copySelection(formattedText);
               } catch (e) {
                    copyQ('error(\"Replace failed, falling back: \" + e)');
                    remove(currentIdx);
                    add(formattedText);
                    // Consider if write is necessary depending on CopyQ behavior
                    // write(index(), formattedText);
                    copy(formattedText);
                    copySelection(formattedText);
               }
           } else {
               // No valid item, just add new and copy
               add(formattedText);
               copy(formattedText);
               copySelection(formattedText);
               copyQ('warning(\"No item selected for replace, added new item instead.\")');
           }
        } else { // Default 'copy' mode
            copy(formattedText);
            copySelection(formattedText);
        }
    };"
6\Icon=
6\IsScript=true
6\Name=Wrap with Code Block
7\Command="
    copyq:
    var selectedItem1 = selectedItemData(0)[mimeText]
    var selectedItem2 = selectedItemData(1)[mimeText]

    var item1 = null
    var item2 = null

    if (selectedItem2 == undefined) {
        // the selected item either doesn't contain text
        // or the command is run as global shortcut.
        // select the last two clipboard in this case.
        item1 = read(1)
        item2 = read(0)
    } else {
        item1 = selectedItem1
        item2 = selectedItem2
    }

    function tempFile(content) {
        var file = new TemporaryFile()
        file.openWriteOnly()
        file.write(content)
        file.close()
        return file
    }

    var f1 = tempFile(item1)
    var f2 = tempFile(item2)
    var name1 = f1.fileName()
    var name2 = f2.fileName()

    execute('meld', name1, name2)

    sleep(100)"
7\Icon=
7\InMenu=true
7\Name=Diff Selected Items
8\Command="
    copyq:
    var itemsToDelete = 50;

    // Create a selection of all items in the current tab
    var sel = ItemSelection(selectedTab()).selectAll();

    // Get all items and their sizes
    var items = sel.items();
    var itemSizes = items.map(function(item, index) {
        return {
            index: index,
            size: str(item[mimeText]).length
        };
    });

    // Sort items by size (descending)
    itemSizes.sort(function(a, b) {
        return b.size - a.size;
    });


    // Select and remove the largest 100 items
    //var largestItemsSel = ItemSelection(selectedTab());
    const removed = []
    for (var i = 0; i < Math.min(itemsToDelete, itemSizes.length); i++) {
        removed.push(itemSizes[i].size)
        remove(itemSizes[i].index);
    }

    // Print the number of removed items
    const totalKb = Math.floor(removed.reduce((a, b) => a + b, 0) / 1024);
    popup(`Removed ${itemsToDelete} items with a total of: ${totalKb} Kbytes`);
    //largestItemsSel.removeAll();"
8\InMenu=true
8\Name=Delete 50 Biggest Items
size=8