[Commands]
1\Command="const _print = global.print;\nglobal.print = function (arg) {\n    popup(arg);\n    _print(arg + \"\\n\");\n}\n\nglobal.popup = function (title, message) {\n    var commandArgs = [\"notify-send\", \"-t\", \"50\", \"-i\", \"copyq\", \"-a\", \"Clipboard\", \"-e\"];\n    commandArgs.push(title)\n    if (message) { commandArgs.push(message) };\n    var out = execute.apply(null, commandArgs);\n}\n\nconst clipboardTab = '&Clipboard';\nconst selectionTab = '&Primary Selection';\nconst imageTab = '&Images';\nconst timeFormat = 'MM-dd hh:mm:ss'\nconst tagsMime = 'application/x-copyq-tags';\nconst imageMime = 'image/png';\nconst mimeHtml = 'text/html';\nconst mimeText = 'text/plain';\n\nvar paste_ = global.paste;\nglobal.paste = function () {\n    paste_();\n}\n\nvar onClipboardChanged_ = onClipboardChanged;\nonClipboardChanged = function () {\n    var time = Date.now()\n    setData('application/x-copyq-user-copy-time', time)\n    let tags = dateString(timeFormat); // Existing time stamp tag\n\n    // Runs only for clipboard changes (i.e.: not primary selection)\n    if (isClipboard()) {\n        const formats = dataFormats();\n    \n        // Fix for Chrome image issue\n        const imageData = clipboard(imageMime);\n        if (imageData.length > 0 || hasImageFormat(formats)) {\n            removeData(mimeText)\n            setData(mimeOutputTab, imageTab);\n            setData(imageMime, imageData);\n        } else {\n            const clipboardText = str(read(\"text/plain\"));\n            const numLines = (clipboardText.match(/\\n/g) || []).length + 1; // Count lines\n\n            // Add number of lines to tags\n            tags = 'Lines: ' + numLines + ',' + tags;\n\n            const languageDetected = detectLanguage(clipboardText);\n            if (languageDetected) {\n                tags = languageDetected + ',' + tags;\n\n                // Perform syntax highlighting\n                highlightCode(clipboardText, languageDetected);\n            }\n            setData(tagsMime, tags);\n            setData(mimeOutputTab, clipboardTab);\n        }\n        setCurrentTab(data(mimeOutputTab))\n    } else {\n        setData(mimeOutputTab, selectionTab);\n        const formats = dataFormats();\n        if (hasImageFormat(formats)) {\n            print(\"Got an image on primary selection?\")\n        } else {\n            const clipboardText = str(read(\"text/plain\"));\n            const numLines = (clipboardText.match(/\\n/g) || []).length + 1; // Count lines\n\n            // Add number of lines to tags\n            tags = \"Lines: \" + numLines + ',' + tags;\n\n            const languageDetected = detectLanguage(clipboardText);\n            if (languageDetected) {\n                tags = languageDetected + ',' + tags;\n                setData(tagsMime, tags);\n\n                // Perform syntax highlighting\n                highlightCode(clipboardText, languageDetected);\n            }\n        }\n    }\n\n    onClipboardChanged_();\n}\n\nglobal.hasImageFormat = function (formats) {\n    for (const format of formats.values()) {\n        if (format.startsWith('image/'))\n            return true;\n    }\n    return false;\n}\n\nglobal.detectLanguage = function (text) {\n    // Call Python to check with Pygments for CSS\n//    const pythonCode = `\n//import sys\n//from pygments.lexers import guess_lexer, ClassNotFound\n\n//text = sys.stdin.read()\n//try:\n//    lexer = guess_lexer(text)\n//    print(lexer.name.lower())  # Output the detected language\n//except ClassNotFound:\n//    print(\"\")  # No match found\n//`;\n\n//    const result = execute('python3', '-c', pythonCode, text);\n\n\n    const highConfidencePatterns = {\n        \"python\": /\\bdef\\s+\\w+\\s*\\(.*\\):|\\bfrom\\s+[^\\s]+\\s+import\\s|import\\s+\\w+(\\s+as\\s+\\w+)?\\s*$|\\bclass\\s+\\w+(\\(.*\\))?:/gm,\n        \"javascript\": /\\b(const|let|var)\\s+\\w+\\s*=\\s*.*;|\\bfunction\\s+\\w*\\s*\\(.*\\)\\s*\\{|\\b=>\\s*\\{|\\bimport\\s+.+\\s+from\\s+['\"].+['\"];?/gm,\n        \"html\": /^\\s*<!DOCTYPE\\s+html>|<html[\\s>]/i,\n        \"csharp\": /^\\s*namespace\\s+\\w+(\\.\\w+)*\\s*\\{|\\bpublic\\s+(class|interface|struct|enum)\\s+\\w+\\s*(?::\\s*\\w+)?\\s*\\{|\\busing\\s+System(\\.\\w+)*\\s*;/gm,\n        \"cpp\": /^\\s*#include\\s*<[^>]+>|\\bint\\s+main\\s*\\(.*\\)\\s*\\{|\\bstd::\\w+/gm,\n        \"java\": /^\\s*public\\s+(class|interface|enum)\\s+\\w+(\\s+extends\\s+\\w+)?(\\s+implements\\s+[\\w,\\s]+)?\\s*\\{|\\bimport\\s+java\\.\\w+/gm,\n        \"go\": /^\\s*package\\s+\\w+|\\bfunc\\s+\\w+\\s*\\(.*\\)\\s*\\{|\\btype\\s+\\w+\\s+struct\\s*\\{/gm,\n        \"php\": /^<\\?php|\\bfunction\\s+\\w+\\s*\\(.*\\)\\s*\\{|\\bclass\\s+\\w+\\s*(?:extends\\s+\\w+)?\\s*\\{/gm,\n//        \"kotlin\": /^\\s*fun\\s+\\w+\\s*\\(.*\\)\\s*(?::\\s*\\w+)?\\s*\\{|\\bclass\\s+\\w+(\\s*:\\s*\\w+)?\\s*\\{|\\bimport\\s+[\\w\\.]+/gm,\n//        \"css\": /(?:(?:[.#]?[\\w\\-]+|[*]|[a-zA-Z][a-zA-Z0-9]*)\\s*{(?:\\s*[\\w\\-]+\\s*:\\s*[^;}]+\\s*;?\\s*)+})/gm,\n    };\n\n    const lowConfidencePatterns = {\n        \"python\": /\\bprint\\s*\\(.*\\)\\s*$|\\bif\\s+.*:\\s*$|\\bfor\\s+.*:\\s*$|\\bwhile\\s+.*:\\s*$|\\btry:\\s*$|\\bexcept\\s+.*:\\s*$|\\bwith\\s+.*:\\s*$/gm,\n        \"javascript\": /console\\.(log|warn|error)\\(.*\\);?$|document\\.\\w+\\(.*\\);?$|window\\.\\w+\\(.*\\);?$/gm,\n        \"html\": /<\\/?(div|span|p|a|img|ul|li|table|tr|td|script|style|head|body|meta|link)[\\s>]/i,\n        \"csharp\": /Console\\.\\w+\\(.*\\);?$|using\\s+System(\\.\\w+)*\\s*;/gm,\n        \"cpp\": /\\bcout\\s*<<.*;?$|\\bcin\\s*>>.*;?$|#define\\s+\\w+/gm,\n        \"java\": /System\\.out\\.print(ln)?\\(.*\\);?$|\\bScanner\\s+\\w+\\s*=\\s*new\\s+Scanner\\(.*\\);?$|\\bpublic\\s+static\\s+void\\s+main\\s*\\(.*\\)\\s*\\{/gm,\n        \"go\": /fmt\\.\\w+\\(.*\\);?$|\\bmake\\(\\w+\\)|\\bappend\\(\\w+,\\s*\\w+\\)/gm,\n        \"kotlin\": /\\bprintln\\(.+\\);?$|\\bwhen\\s*\\(.*\\)\\s*\\{/gm,\n    };\n\n    // Attempt to detect JSON by parsing\n    try {\n        JSON.parse(text);\n        return \"json\";\n    } catch (e) {\n        // Not JSON, proceed with regex detection.\n    }\n\n    // Assign weights\n    const highConfidenceWeight = 10;\n    const lowConfidenceWeight = 1;\n\n    let scores = {};\n\n    // High confidence patterns\n    for (const lang in highConfidencePatterns) {\n        const pattern = highConfidencePatterns[lang];\n        const matches = (text.match(pattern) || []).length;\n        if (matches > 0) {\n            scores[lang] = (scores[lang] || 0) + matches * highConfidenceWeight;\n        }\n    }\n\n    // Low confidence patterns\n    for (const lang in lowConfidencePatterns) {\n        const pattern = lowConfidencePatterns[lang];\n        const matches = (text.match(pattern) || []).length;\n        if (matches > 0) {\n            scores[lang] = (scores[lang] || 0) + matches * lowConfidenceWeight;\n        }\n    }\n\n    // Determine the language with the highest score\n    const sortedLanguages = Object.keys(scores).sort((a, b) => scores[b] - scores[a]);\n    if (sortedLanguages.length === 0) return \"\";\n\n    const topLanguage = sortedLanguages[0];\n    const topScore = scores[topLanguage];\n    const secondScore = scores[sortedLanguages[1]] || 0;\n\n    // Uncomment the following line to see the scores during debugging\n//    popup(`${topLanguage} ${topScore} ${secondScore}`);\n\n    // Check if the top score is significantly higher than the second\n    if (topScore > 5 && topScore > secondScore * 1.5) {\n        return topLanguage;\n    }\n    return \"\";\n}\n\n// Function to perform syntax highlighting\nglobal.highlightCode = function (text, language) {\n    // Map detected language names to Pygments lexer names\n    const languageMap = {\n        \"python\": \"python\",\n        \"javascript\": \"javascript\",\n        \"html\": \"html\",\n        \"php\": \"php\",\n        \"csharp\": \"csharp\",\n        \"cpp\": \"cpp\",\n        \"java\": \"java\",\n        \"go\": \"go\",\n        \"kotlin\": \"kotlin\",\n        \"json\": \"json\",\n        \"css\": \"css\",\n    };\n\n    const pygmentsLanguage = languageMap[language];\n    if (!pygmentsLanguage) {\n        // Language not supported by Pygments\n        return;\n    }\n\n    // Prepare the command to run Pygments\n    const pythonCode = `\nimport sys\nfrom pygments import highlight\nfrom pygments.lexers import get_lexer_by_name\nfrom pygments.formatters import HtmlFormatter\n\ncode = sys.stdin.read()\nlexer = get_lexer_by_name(sys.argv[1])\nformatter = HtmlFormatter(noclasses=True, style='solarized-dark', encoding='utf-8')\nformatter.style.background_color = 'none'\nprint(highlight(code, lexer, formatter).decode())\n`;\n\n    // Execute Pygments to get the highlighted HTML\n    const result = execute('python3', '-c', pythonCode, pygmentsLanguage, null, text);\n\n    if (result && result.exit_code === 0) {\n        const html = result.stdout;\n        // Set the HTML data for the item\n        setData(mimeHtml, html);\n    } else {\n        // Handle error\n        print('Error highlighting code: ' + (result ? result.stderr : 'Unknown error'));\n    }\n}\n"
1\Icon=\xf15b
1\IsScript=true
1\Name=Globals and Overrides
10\Command="// Pops up the main window (if the shortcut is pressed once)\n// If the shortcut is pressed again, walks through the list\n// and immediately activates the selected item when releeased.\n\n// Bind shortcuts similar to:\n// - Super+Q = copyq cycle false\n// - Super+Shift+Q = copyq cycle true\n\nglobal.cycle = function(oppositeDirection) {\n    if (focused()) {\n        const sel = ItemSelection().current();\n        const rows = sel.rows();\n        var direction = Number(settings('cycleItemsSelectDirection'));\n\n        // Toggle direction based on the oppositeDirection flag\n        direction = oppositeDirection ? -direction : direction;\n\n        var row = rows.length > 0 ? (rows[0] + direction) : 0;\n        if (row < 0 || row >= length()) {\n            row = (rows.length > 0) ? (rows[0] + direction) : 0; // ensure row recalculates correctly\n        }\n        settings('cycleItemsSelectedRow', row);\n        settings('cycleItemsSelectedTab', selectedTab());\n        selectItems(row);\n    } else {\n        settings('cycleItemsSelectedRow', -1);\n        settings('cycleItemsSelectDirection', 1);\n        show();\n        // Wait for shortcut modifiers to be released.\n        while (queryKeyboardModifiers().length > 0) {\n            sleep(20);\n        }\n        const row = settings('cycleItemsSelectedRow');\n        if (row != -1) {\n            tab(settings('cycleItemsSelectedTab'));\n            select(row);\n            hide();\n            // uncomment this to also paste:'cycleItemsSelectDirection'// uncomment this to also paste\n            // paste()\n        }\n    }\n};\n"
10\Enable=false
10\Icon=\xf1b8
10\IsScript=true
10\Name=Cycle Items
11\Command="copyq:\nvar snippetsTabName = 'Snippets'\n// List snippets instead of search combo box?\nvar listSnippets = true\n\nfunction newVarRe(content) {\n  return new RegExp('\\\\${' + content + '}', 'g')\n}\n\nfunction getText(item, format) {\n  return str(item[format] || '')\n}\n\nfunction assignPlaceholder(snippet, placeholder, value) {\n  return snippet.replace(newVarRe(placeholder + ':?.*?'), value)\n}\n\nfunction fuzzyIndexOf(snippetNames, snippetName) {\n    var re = new RegExp(snippetName, 'i')\n    for (var i in snippetNames) {\n      if (snippetNames[i].match(re))\n        return i;\n    }\n    return -1\n}\n\nfunction loadSnippets(snippetNames, snippets)\n{\n  var tabs = tab()\n  for (var i in tabs) {\n    var tabName = tabs[i];\n    if (tabName != snippetsTabName && tabName.indexOf(snippetsTabName + '/') != 0)\n      continue;\n\n    tab(tabName)\n    var prefix = tabName.substring(snippetsTabName.length + 1)\n    if (prefix)\n      prefix += ': '\n    for (var j = 0; j < size(); ++j) {\n      var snippet = getitem(j)\n      var snippetName = getText(snippet, mimeItemNotes)\n          || getText(snippet, mimeText)\n          || getText(snippet, mimeHtml)\n      snippetNames.push(prefix + snippetName)\n      snippets.push(snippet)\n    }\n  }\n}\n\nfunction askForSnippet(snippetNames, snippets) {\n  var list = listSnippets ? '.list:' : ''\n\n  var settingsPrefix = 'snippets/'\n\n  var optSnippet = 'Snippet'\n  var snippetName = settings(settingsPrefix + optSnippet)\n\n  var snippet = dialog(\n    '.title', 'Select Snippet',\n    '.defaultChoice', snippetName,\n    list + optSnippet, snippetNames\n  )\n\n  if (snippet === undefined) {\n    abort()\n  }\n\n  settings(settingsPrefix + optSnippet, listSnippets ? snippetNames[snippet] : snippet)\n\n  if (listSnippets)\n      return snippets[snippet]\n\n  var i = snippetNames.indexOf(snippet)\n  if (i != -1)\n    return snippets[i]\n\n  i = fuzzyIndexOf(snippetNames, snippet)\n  if (i != -1)\n    return snippets[i]\n\n  popup(\n    'Snippet Not Found',\n    'No matching snippet found for \"' + snippetName + '\"!'\n  )\n  abort()\n}\n\nfunction getPlaceholders(snippet) {\n  var placeholders = {}\n  var m\n  var reVar = newVarRe('([^:}]*):?(.*?)')\n  while ((m = reVar.exec(snippet)) !== null) {\n    if (!(m[1] in placeholders))\n      placeholders[m[1]] = m[2].replace('\\\\n', '\\n')\n  }\n\n  return placeholders\n}\n\nfunction assignPlaceholders(text, values) {\n  if (!(values instanceof Object)) {\n    text = assignPlaceholder(text, '.*?', values)\n  } else {\n    for (var name in values)\n      text = assignPlaceholder(text, name, values[name])\n  }\n\n  return text\n}\n\nfunction askToAssignPlaceholders(snippet, format, values) {\n  var text = getText(snippet, format)\n  var placeholders = getPlaceholders(text)\n\n  if (Object.keys(placeholders).length < 1)\n    return\n\n  if (values) {\n    snippet[format] = assignPlaceholders(text, values)\n    return values\n  }\n\n  var label = escapeHtml(text)\n    .replace(newVarRe('([^:}]*).*?'), '<b>$1</b>')\n\n  var dialogVars = [\n    '.title', 'Set Snippet Values',\n    '.label', label\n  ]\n\n  for (var name in placeholders) {\n    var values = placeholders[name].split(',')\n    dialogVars.push(name)\n    dialogVars.push((values.length == 1) ? values[0] : values)\n  }\n\n  var values = dialog.apply(this, dialogVars) || abort()\n  snippet[format] = assignPlaceholders(text, values)\n  return values\n}\n\nfunction pasteSnippet(mime, content) {\n  copy(mime, content)\n  copySelection(mime, content)\n  paste()\n}\n\nvar snippetNames = []\nvar snippets = []\nloadSnippets(snippetNames, snippets)\n\nvar snippet = askForSnippet(snippetNames, snippets)\n\nvalues = askToAssignPlaceholders(snippet, mimeText)\naskToAssignPlaceholders(snippet, mimeHtml, values)\n\npasteSnippet(mimeItems, pack(snippet))"
11\Enable=false
11\GlobalShortcut=ctrl+alt+shift+x
11\Icon=\xf1fb
11\IsGlobalShortcut=true
11\Name=Snippets
12\Command=copyq: plugins.itemtags.tag()
12\Enable=false
12\Icon=\xf02b
12\InMenu=true
12\InternalId=copyq_tags_tag
12\Name=Add a Tag
13\Command=copyq: plugins.itemtags.untag()
13\Enable=false
13\Icon=\xf02b
13\InMenu=true
13\Input=application/x-copyq-tags
13\InternalId=copyq_tags_untag
13\Name=Remove a Tag
14\Command=copyq: plugins.itemtags.clearTags()
14\Enable=false
14\Icon=\xf02b
14\InMenu=true
14\Input=application/x-copyq-tags
14\InternalId=copyq_tags_clear
14\Name=Clear all tags
15\Command=copyq: (plugins.itemtags.hasTag(decodeURIComponent('python')) ? plugins.itemtags.untag : plugins.itemtags.tag)(decodeURIComponent('python'))
15\Enable=false
15\Icon=\xf02b
15\InMenu=true
15\InternalId=copyq_tags_tag:python
15\Name=Toggle Tag \x201cpython\x201d
16\Command=copyq: (plugins.itemtags.hasTag(decodeURIComponent('javascript')) ? plugins.itemtags.untag : plugins.itemtags.tag)(decodeURIComponent('javascript'))
16\Enable=false
16\Icon=\xf02b
16\InMenu=true
16\InternalId=copyq_tags_tag:javascript
16\Name=Toggle Tag \x201cjavascript\x201d
17\Command=copyq: (plugins.itemtags.hasTag(decodeURIComponent('golang')) ? plugins.itemtags.untag : plugins.itemtags.tag)(decodeURIComponent('golang'))
17\Enable=false
17\Icon=\xf02b
17\InMenu=true
17\InternalId=copyq_tags_tag:golang
17\Name=Toggle Tag \x201cgolang\x201d
18\Command=copyq: (plugins.itemtags.hasTag(decodeURIComponent('html')) ? plugins.itemtags.untag : plugins.itemtags.tag)(decodeURIComponent('html'))
18\Enable=false
18\Icon=\xf02b
18\InMenu=true
18\InternalId=copyq_tags_tag:html
18\Name=Toggle Tag \x201chtml\x201d
19\Command=copyq: (plugins.itemtags.hasTag(decodeURIComponent('markdown')) ? plugins.itemtags.untag : plugins.itemtags.tag)(decodeURIComponent('markdown'))
19\Enable=false
19\Icon=\xf02b
19\InMenu=true
19\InternalId=copyq_tags_tag:markdown
19\Name=Toggle Tag \x201cmarkdown\x201d
2\Command="copyq:\nglobal.copyImageToClipboard = function(path) {\n    const imageTab = '&Images';\n    var f = new File(path)\n    if (!f.openReadOnly())\n        throw 'Failed to open the file: ' + f.errorString()\n    var bytes = f.readAll()\n    \n    tab(imageTab)\n    setCurrentTab(imageTab)\n    // Write the image data to the clipboard with the MIME type 'image/png'\n    write(0, 'image/png', bytes);\n    copy('image/png', bytes);\n}"
2\Input=image/png
2\IsScript=true
2\Name=Copy PNG File Contents
2\Tab=&Images
20\Command=copyq: (plugins.itemtags.hasTag(decodeURIComponent('java')) ? plugins.itemtags.untag : plugins.itemtags.tag)(decodeURIComponent('java'))
20\Enable=false
20\Icon=\xf02b
20\InMenu=true
20\InternalId=copyq_tags_tag:java
20\Name=Toggle Tag \x201cjava\x201d
21\Command=copyq: (plugins.itemtags.hasTag(decodeURIComponent('bash')) ? plugins.itemtags.untag : plugins.itemtags.tag)(decodeURIComponent('bash'))
21\Enable=false
21\Icon=\xf02b
21\InMenu=true
21\InternalId=copyq_tags_tag:bash
21\Name=Toggle Tag \x201c\x62\x61sh\x201d
3\Command="/**\n * Uploads content to either a Markdown or code sharing service based on the specified type.\n * - Checks existing tags to avoid duplicate uploads.\n * - Trims all tags to remove leading or trailing whitespace.\n * - Handles uploading to different endpoints based on the content type.\n * @param {string} type - The type of the content to upload, either 'code' or 'markdown'.\n */\nglobal.upload = function(type = \"code\") {\n    const row = currentItem();\n    const currentTags = getTags(row);\n\n    // Check if a markdown or hastebin link already exists in the tags\n    const existingLink = findExistingLink(currentTags);\n    if (existingLink) return;  // Exit if a link already exists\n\n    const itemText = getItemText(row);\n    let responseParsed;\n    if (type == 'markdown') {\n        var finalMarkdown = escapeSpecialChars(itemText);\n        responseParsed = postMarkdown(finalMarkdown);\n    } else if (type == 'code') {\n        responseParsed = postCode(itemText);\n    }\n\n    // Handle response and process the link\n    if (handleResponseErrors(responseParsed)) {\n        const link = processLink(responseParsed, type);\n        updateTagAndCopyLink(row, link, type);\n    }\n};\n\nfunction getTags(row) {\n    return str(read(\"application/x-copyq-tags\", row)).split(\",\")\n           .map(tag => tag.trim());  // Trim each tag to remove any leading or trailing whitespace\n}\n\nfunction findExistingLink(tags) {\n    return tags.find(tag => tag.startsWith(\"Markdown: \") || tag.startsWith(\"Hastebin: \"));\n}\n\nfunction getItemText(row) {\n    return str(read(row));\n}\n\nfunction escapeSpecialChars(str) {   \n    return str.replace(/```/g, \"\\`\\`\\`\");\n}\n\nfunction postMarkdown(bodyText) {\n    const endpoint = \"https://paper.wf/api/posts\";\n    const postData = JSON.stringify({ \"body\": bodyText });\n    const headers = [\n        \"-H\", \"Content-Type: application/json\",\n        \"-H\", \"Authorization: Token 1afc5558-f587-4012-4e93-1d33a16df8d5\"\n    ];\n    const response = execute(\"curl\", \"-s\", \"-X\", \"POST\", endpoint, ...headers, \"-d\", postData);\n    return JSON.parse(str(response.stdout));\n}\n\nfunction postCode(bodyText) {\n    const endpoint = \"https://haste.zneix.eu/documents\";\n    const headers = [\"-H\", \"User-Agent: haste-client/1.2\"];\n    const response = execute(\"curl\", \"-s\", \"-X\", \"POST\", endpoint, ...headers, \"--data\", bodyText);\n    const jsonResponse = JSON.parse(str(response.stdout));\n    return { data: { url: `https://haste.zneix.eu/${jsonResponse.key}` } };\n}\n\nfunction handleResponseErrors(response) {\n    if (response.exit_code || response.stderr || response.error) {\n        const errorMessage = `Failed to upload post: ${response.stderr} ${response.error}`;\n        popup(errorMessage);\n        abort();\n        return false;\n    }\n    return true;\n}\n\nfunction processLink(response, type = \"code\") {\n    if (type == \"markdown\") {\n        url = response.data.url.slice(0, -3);\n    } else {\n        url = response.data.url;\n    }\n    return url;\n}\n\nfunction updateTagAndCopyLink(row, link, type) {\n    const prefix = type === 'code' ? 'Hastebin: ' : 'Markdown: ';\n    const tagData = `${prefix}${link}`;\n    \n    const currentData = str(read(\"application/x-copyq-tags\", row));\n    setData(\"application/x-copyq-tags\", `${tagData},${currentData}`, row);\n    copy(link);\n}\n"
3\Icon=\xf15b
3\IsScript=true
3\Name=Upload to Write.as or Hastebin
4\Command="copyq:\nvar color = 'rgba(255, 255, 0, 1)'\nvar currentColor = str(selectedItemData(0)[mimeColor]);\nif (currentColor != color) {\n    setData(mimeColor, color)\n} else {\n    removeData(mimeColor)\n}"
4\Icon=\xf591
4\InMenu=true
4\MatchCommand="copyq:\nvar color = 'rgba(255, 255, 0, 0.5)'\nvar currentColor = str(selectedItemData(0)[mimeColor])\nif (currentColor != color) {\n    menuItem['text'] = 'Mark Items'\n    menuItem['tag'] = '__'\n    menuItem['color'] = color.replace(/\\d+\\.\\d+/, 1)\n} else {\n    menuItem['text'] = 'Unmark Items'\n    menuItem['tag'] = 'x'\n    menuItem['color'] = 'white'\n}\nmenuItem['icon'] = '\xf591'"
4\Name=Highlight Items
5\Command="global.codeblock = function (mode = 'copy') {\n    // Step 1: Check the clipboard content\n    var contents = str(clipboard());\n    if (!contents || !contents.trim() || (contents.trim().startsWith(\"```\") && contents.trim().endsWith(\"```\"))) {\n        abort(\"Clipboard is empty, contains only whitespace, or already looks like a code block.\");\n    }\n\n    // Step 2: Define helper functions\n    function escapeSpecialChars(str) {\n        return str.replace(/```/g, \"\\\\`\\\\`\\\\`\");\n    }\n\n    function removeExtraIndentation(text) {\n        const lines = text.split('\\n');\n\n        // Find the index and content of the first line with actual content\n        let firstContentLineIndex = -1;\n        let firstContentLine = null;\n        for (let i = 0; i < lines.length; i++) {\n            if (/\\S/.test(lines[i])) { // Check if the line has non-whitespace characters\n                firstContentLineIndex = i;\n                firstContentLine = lines[i];\n                break;\n            }\n        }\n\n        // If no content lines found, or only one line, return original text\n        if (firstContentLineIndex === -1 || lines.filter(line => /\\S/.test(line)).length <= 1) {\n            return text;\n        }\n\n        const firstLineIndent = firstContentLine.match(/^\\s*/)[0].length;\n\n        // --- Special Case Trigger: First non-empty line starts at column 0 ---\n        if (firstLineIndent === 0) {\n            // Find all *other* non-empty lines (those after the first content line)\n            // Need to consider all lines, not just those after, in case structure is like:\n            // line0\n            //   line1\n            // line0_again\n            const otherContentLines = lines.filter((line, index) =>\n                index !== firstContentLineIndex && /\\S/.test(line)\n            );\n\n\n            // If there are no other content lines, no relative indentation to adjust\n            if (otherContentLines.length === 0) {\n                return text;\n            }\n\n            // Calculate the minimum indentation among these *other* content lines\n            const secondaryMinIndent = Math.min(...otherContentLines.map(line => line.match(/^\\s*/)[0].length));\n\n            // If this secondary minimum is greater than 0, apply the special dedent\n            if (secondaryMinIndent > 0) {\n                return lines.map(line => {\n                    // Only modify lines that ARE indented\n                    if (/^\\s+/.test(line)) { // Check if line starts with whitespace\n                       const currentIndent = line.match(/^\\s*/)[0].length;\n                       // Remove secondaryMinIndent if the line has at least that much indent\n                       if (currentIndent >= secondaryMinIndent) {\n                           return line.substring(secondaryMinIndent);\n                       }\n                    }\n                    // Otherwise (line starts at 0 or has less indent than secondaryMinIndent), return unchanged\n                    return line;\n                }).join('\\n');\n            } else {\n                // If secondaryMinIndent is 0, it means all relevant subsequent lines also start near 0.\n                // No indentation adjustment needed relative to the first line.\n                return text;\n            }\n        } else {\n            // --- Standard Dedent Case: First non-empty line IS indented ---\n            // Find all content lines (including the first one)\n            const allContentLines = lines.filter(line => /\\S/.test(line)); // Reuse filter logic\n\n            // Calculate the minimum indentation across ALL content lines\n            const absoluteMinIndent = Math.min(...allContentLines.map(line => line.match(/^\\s*/)[0].length));\n\n            // If minimum is 0 (shouldn't normally happen here, but safe check), return text\n            if (absoluteMinIndent === 0 ) {\n                 return text;\n            }\n\n            // Remove the absolute minimum indentation from ALL lines\n            return lines.map(line => line.substring(absoluteMinIndent)).join('\\n');\n        }\n    }\n\n\n    // Step 3: Process the content\n    contents = removeExtraIndentation(contents);\n    contents = escapeSpecialChars(contents);\n\n    // Step 4: Detect language and format\n    const language = detectLanguage(contents) || '';\n    const formattedText = `\\`\\`\\`${language}\\n${contents}\\n\\`\\`\\``;\n\n    // Step 5: Output the result (Using the improved replace/copy logic from previous versions)\n    if (mode == \"replace\") {\n       const currentIdx = index();\n       if (currentIdx >= 0) {\n           try {\n               replace(currentIdx, formattedText);\n               // Ensure clipboard consistency after replacing\n               copy(formattedText);\n               copySelection(formattedText);\n           } catch (e) {\n                copyQ('error(\"Replace failed, falling back: \" + e)');\n                remove(currentIdx);\n                add(formattedText);\n                // Consider if write is necessary depending on CopyQ behavior\n                // write(index(), formattedText);\n                copy(formattedText);\n                copySelection(formattedText);\n           }\n       } else {\n           // No valid item, just add new and copy\n           add(formattedText);\n           copy(formattedText);\n           copySelection(formattedText);\n           copyQ('warning(\"No item selected for replace, added new item instead.\")');\n       }\n    } else { // Default 'copy' mode\n        copy(formattedText);\n        copySelection(formattedText);\n    }\n};"
5\Icon=\xf06b
5\IsScript=true
5\Name=Wrap with Code Block
6\Command="copyq:\nvar selectedItem1 = selectedItemData(0)[mimeText]\nvar selectedItem2 = selectedItemData(1)[mimeText]\n\nvar item1 = null\nvar item2 = null\n\nif (selectedItem2 == undefined) {\n    // the selected item either doesn't contain text\n    // or the command is run as global shortcut.\n    // select the last two clipboard in this case.\n    item1 = read(1)\n    item2 = read(0)\n} else {\n    item1 = selectedItem1\n    item2 = selectedItem2\n}\n\nfunction tempFile(content) {\n    var file = new TemporaryFile()\n    file.openWriteOnly()\n    file.write(content)\n    file.close()\n    return file\n}\n\nvar f1 = tempFile(item1)\nvar f2 = tempFile(item2)\nvar name1 = f1.fileName()\nvar name2 = f2.fileName()\n\nexecute('meld', name1, name2)\n\nsleep(100)"
6\Icon=\xf0db
6\InMenu=true
6\Name=Diff Selected Items
7\Command="copyq:\nvar itemsToDelete = 50;\n\n// Create a selection of all items in the current tab\nvar sel = ItemSelection(selectedTab()).selectAll();\n\n// Get all items and their sizes\nvar items = sel.items();\nvar itemSizes = items.map(function(item, index) {\n    return {\n        index: index,\n        size: str(item[mimeText]).length\n    };\n});\n\n// Sort items by size (descending)\nitemSizes.sort(function(a, b) {\n    return b.size - a.size;\n});\n\n\n// Select and remove the largest 100 items\n//var largestItemsSel = ItemSelection(selectedTab());\nconst removed = []\nfor (var i = 0; i < Math.min(itemsToDelete, itemSizes.length); i++) {\n    removed.push(itemSizes[i].size)\n    remove(itemSizes[i].index);\n}\n\n// Print the number of removed items\nconst totalKb = Math.floor(removed.reduce((a, b) => a + b, 0) / 1024);\npopup(`Removed ${itemsToDelete} items with a total of: ${totalKb} Kbytes`);\n//largestItemsSel.removeAll();"
7\Icon=\xef\xbf\xbd\x34\x36
7\InMenu=true
7\Name=Delete 50 Biggest Items
8\Automatic=true
8\Command="copyq:\nvar waitMs = 2500;\n\nvar start = Date.now();\nwhile (queryKeyboardModifiers().length > 0\n       && Date.now() - start < waitMs) { }\n\nif (queryKeyboardModifiers().length >= 2) {\n    popup(\"Copied as secret because you held two modifiers\");\n    ignore();\n}"
8\Enable=false
8\Icon=\xf070
8\Name=Copy Secrets If Modifier Held
9\Command="/**\n * Cycles through and pastes the next item in the list sequentially.\n * This function is designed for efficient sequential pasting of items.\n *\n * Usage:\n * - Bind `copyq pasteNext` to a global shortcut, such as Super+V.\n * - Copy multiple items in sequence.\n * - Press Super+V repeatedly to paste each item in turn.\n */\n\nglobal.pasteNext = function () {\n    const items = selectedItems();\n    if (items.length != 1) return;\n    const ix = items[0];\n\n    tab(selectedtab())\n    if (ix === 0) {\n        print(\"Pasting first item\");\n        paste();\n        selectItems([ix + 1]);\n        return;\n    }\n    print(`Selecting index ${ix + 1}`);\n    selectItems([ix + 1]);\n    item = selectedItemsData()[0]\n    copy(item)\n    paste()\n}\n\n"
9\Enable=false
9\GlobalShortcut=alt+shift+v
9\Icon=\xe4bb
9\IsGlobalShortcut=true
9\IsScript=true
9\Name=Paste Next
size=21
